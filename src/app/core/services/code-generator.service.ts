import { Injectable, signal, computed } from '@angular/core';
import { 
  GeneratedComponent, 
  CodeGenerationConfig, 
  GenerationContext, 
  FormControlDefinition,
  ImportStatement,
  ComponentMetadata
} from '../models';

@Injectable({
  providedIn: 'root'
})
export class CodeGeneratorService {
  public generationInProgress = signal(false);
  public lastGeneratedCode = signal<GeneratedComponent | null>(null);

  // Computed properties
  readonly isGenerating = computed(() => this.generationInProgress());
  readonly lastGenerated = computed(() => this.lastGeneratedCode());

  // Template cache for performance
  public templateCache = new Map<string, string>();

  constructor() {
    this.initializeTemplates();
  }

  /**
   * Generate complete Angular component from structure
   */
  generateComponent(structure: any, config: CodeGenerationConfig): GeneratedComponent {
    this.generationInProgress.set(true);
    
    try {
      const context = this.createGenerationContext(structure, config);
      
      const generatedComponent: GeneratedComponent = {
        name: config.componentName,
        selector: config.selector,
        typescript: this.generateTypeScript(context),
        template: this.generateTemplate(context),
        styles: this.generateStyles(context),
        spec: config.generateTests ? this.generateTests(context) : undefined,
        dependencies: this.resolveDependencies(context),
        metadata: this.createComponentMetadata(config)
      };

      this.lastGeneratedCode.set(generatedComponent);
      return generatedComponent;

    } finally {
      this.generationInProgress.set(false);
    }
  }

  /**
   * Create generation context from structure and config
   */
  public createGenerationContext(structure: any, config: CodeGenerationConfig): GenerationContext {
    const formControls = this.extractFormControls(structure.components || []);
    
    return {
      config,
      structure,
      name: config.componentName,
      selector: config.selector,
      className: this.pascalCase(config.componentName),
      formControls,
      imports: new Set(['Component']),
      dependencies: new Set(['@angular/core'])
    };
  }

  /**
   * Generate TypeScript component class
   */
  public generateTypeScript(context: GenerationContext): string {
    const { className, formControls, config } = context;
    
    // Add reactive forms imports if needed
    if (formControls.length > 0) {
      context.imports.add('FormBuilder');
      context.imports.add('FormGroup');
      context.imports.add('Validators');
      context.dependencies.add('@angular/forms');
    }

    // Add OnInit if needed
    if (formControls.length > 0) {
      context.imports.add('OnInit');
    }

    const imports = this.generateImports(context);
    const formGroupDefinition = this.generateFormGroup(context);
    const constructor = this.generateConstructor(context);
    const lifecycle = this.generateLifecycleMethods(context);
    const methods = this.generateMethods(context);
    const properties = this.generateProperties(context);

    return `${imports}

@Component({
  selector: '${context.selector}',
  standalone: true,
  imports: [${this.generateComponentImports(context)}],
  templateUrl: './${context.name}.component.html',
  styleUrl: './${context.name}.component.css'
})
export class ${className}Component${formControls.length > 0 ? ' implements OnInit' : ''} {
${properties}

${formGroupDefinition}

${constructor}

${lifecycle}

${methods}
}`;
  }

  /**
   * Generate HTML template
   */
  public generateTemplate(context: GenerationContext): string {
    const { structure, formControls } = context;
    
    let template = '';
    
    if (formControls.length > 0) {
      template = `<form [formGroup]="form" (ngSubmit)="onSubmit()" class="form-container">
${this.generateComponentsHTML(structure.components || [], 1)}
</form>`;
    } else {
      template = `<div class="container">
${this.generateComponentsHTML(structure.components || [], 1)}
</div>`;
    }

    return this.formatHTML(template);
  }

  /**
   * Generate CSS styles
   */
  public generateStyles(context: GenerationContext): string {
    const { config } = context;
    
    let styles = `/**
 * ${context.className} Component Styles
 * Generated by Angular Form Constructor
 */

/* Component Container */
.form-container {
  max-width: 600px;
  margin: 0 auto;
  padding: var(--space-6);
}

.container {
  max-width: 600px;
  margin: 0 auto;
  padding: var(--space-6);
}

/* Form Groups */
.form-group {
  margin-bottom: var(--space-4);
}

.form-group:last-child {
  margin-bottom: 0;
}

/* Form Labels */
.form-label {
  display: block;
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  color: var(--gray-700);
  margin-bottom: var(--space-2);
}

.form-label.required::after {
  content: '*';
  color: var(--error-500);
  margin-left: var(--space-1);
}

/* Form Controls */
.form-control {
  display: block;
  width: 100%;
  padding: var(--space-2) var(--space-3);
  font-size: var(--font-size-base);
  line-height: var(--line-height-normal);
  color: var(--gray-900);
  background-color: white;
  border: 1px solid var(--gray-300);
  border-radius: var(--radius-md);
  transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
}

.form-control:focus {
  outline: none;
  border-color: var(--primary-500);
  box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
}

.form-control:disabled {
  background-color: var(--gray-50);
  color: var(--gray-500);
  cursor: not-allowed;
}

/* Form Validation */
.form-control.ng-invalid.ng-touched {
  border-color: var(--error-500);
}

.form-error {
  margin-top: var(--space-1);
  font-size: var(--font-size-sm);
  color: var(--error-600);
}

/* Checkboxes */
.form-check {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.form-check-input {
  width: 1rem;
  height: 1rem;
  accent-color: var(--primary-600);
}

.form-check-label {
  font-size: var(--font-size-base);
  color: var(--gray-700);
  cursor: pointer;
  margin: 0;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-2) var(--space-4);
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  border: 1px solid transparent;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
  text-decoration: none;
}

.btn-primary {
  color: white;
  background-color: var(--primary-600);
  border-color: var(--primary-600);
}

.btn-primary:hover:not(:disabled) {
  background-color: var(--primary-700);
  border-color: var(--primary-700);
}

.btn-secondary {
  color: var(--gray-700);
  background-color: white;
  border-color: var(--gray-300);
}

.btn-secondary:hover:not(:disabled) {
  background-color: var(--gray-50);
  border-color: var(--gray-400);
}

/* Layout Utilities */
.w-full {
  width: 100%;
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.gap-4 {
  gap: var(--space-4);
}

/* Responsive Design */
@media (max-width: 768px) {
  .form-container,
  .container {
    padding: var(--space-4);
  }
}`;

    if (config.responsive) {
      styles += this.generateResponsiveStyles();
    }

    return styles;
  }

  /**
   * Generate component HTML from structure
   */
  public generateComponentsHTML(components: any[], depth: number): string {
    const indent = '  '.repeat(depth);
    
    return components.map(component => {
      const type = this.getComponentType(component);
      
      switch (type) {
        case 'angular-input-field':
          return this.generateInputHTML(component, depth);
        case 'angular-select-field':
          return this.generateSelectHTML(component, depth);
        case 'angular-checkbox-field':
          return this.generateCheckboxHTML(component, depth);
        case 'angular-button':
          return this.generateButtonHTML(component, depth);
        case 'angular-container':
          return this.generateContainerHTML(component, depth);
        default:
          return `${indent}<!-- Unknown component type: ${type} -->`;
      }
    }).join('\n');
  }

  public generateInputHTML(component: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const props = this.getComponentProperties(component);
    const controlName = props.formControlName || props.name || 'inputField';
    
    return `${indent}<div class="form-group">
${indent}  <label class="form-label${props.required ? ' required' : ''}" for="${controlName}">
${indent}    ${props.label || 'Input Label'}
${indent}  </label>
${indent}  <input 
${indent}    type="${props.inputType || props.type || 'text'}"
${indent}    class="form-control"
${indent}    id="${controlName}"
${indent}    formControlName="${controlName}"
${indent}    placeholder="${props.placeholder || ''}"
${indent}    ${props.required ? 'required' : ''}
${indent}    ${props.disabled ? 'disabled' : ''}
${indent}    ${props.readonly ? 'readonly' : ''}
${indent}  />
${this.generateValidationHTML(controlName, props, depth + 1)}
${indent}</div>`;
  }

  public generateSelectHTML(component: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const props = this.getComponentProperties(component);
    const controlName = props.formControlName || props.name || 'selectField';
    const options = props.options || [
      { value: 'option1', label: 'Option 1' },
      { value: 'option2', label: 'Option 2' }
    ];
    
    return `${indent}<div class="form-group">
${indent}  <label class="form-label${props.required ? ' required' : ''}" for="${controlName}">
${indent}    ${props.label || 'Select Label'}
${indent}  </label>
${indent}  <select 
${indent}    class="form-control"
${indent}    id="${controlName}"
${indent}    formControlName="${controlName}"
${indent}    ${props.required ? 'required' : ''}
${indent}    ${props.disabled ? 'disabled' : ''}
${indent}    ${props.multiple ? 'multiple' : ''}
${indent}  >
${indent}    <option value="" disabled>Choose an option</option>
${options.map((opt: any) => 
  `${indent}    <option value="${opt.value}">${opt.label}</option>`
).join('\n')}
${indent}  </select>
${this.generateValidationHTML(controlName, props, depth + 1)}
${indent}</div>`;
  }

  public generateCheckboxHTML(component: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const props = this.getComponentProperties(component);
    const controlName = props.formControlName || props.name || 'checkboxField';
    
    return `${indent}<div class="form-group form-check">
${indent}  <input 
${indent}    type="checkbox"
${indent}    class="form-check-input"
${indent}    id="${controlName}"
${indent}    formControlName="${controlName}"
${indent}    value="${props.value || 'true'}"
${indent}    ${props.checked ? 'checked' : ''}
${indent}    ${props.required ? 'required' : ''}
${indent}    ${props.disabled ? 'disabled' : ''}
${indent}  />
${indent}  <label class="form-check-label" for="${controlName}">
${indent}    ${props.label || 'Checkbox Label'}
${indent}  </label>
${this.generateValidationHTML(controlName, props, depth + 1)}
${indent}</div>`;
  }

  public generateButtonHTML(component: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const props = this.getComponentProperties(component);
    
    return `${indent}<button 
${indent}  type="${props.buttonType || 'button'}"
${indent}  class="btn btn-${props.variant || 'primary'} btn-${props.size || 'md'}${props.fullWidth ? ' w-full' : ''}"
${indent}  ${props.disabled ? 'disabled' : ''}
${indent}  (click)="${props.onClick || 'onButtonClick()'}"
${indent}>
${indent}  ${props.loading ? '<span class="loading-spinner mr-1"></span>' : ''}
${indent}  ${props.text || 'Button Text'}
${indent}</button>`;
  }

  public generateContainerHTML(component: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const props = this.getComponentProperties(component);
    const children = component.components || [];
    
    const layoutClass = props.layout ? ` layout-${props.layout}` : '';
    
    return `${indent}<div class="form-container${layoutClass}">
${this.generateComponentsHTML(children, depth + 1)}
${indent}</div>`;
  }

  /**
   * Generate validation HTML for form controls
   */
  public generateValidationHTML(controlName: string, props: any, depth: number): string {
    const indent = '  '.repeat(depth);
    const validationRules = [];
    
    if (props.required) {
      validationRules.push(`${indent}<div *ngIf="form.get('${controlName}')?.errors?.['required']" class="form-error">
${indent}  This field is required
${indent}</div>`);
    }
    
    if (props.minLength) {
      validationRules.push(`${indent}<div *ngIf="form.get('${controlName}')?.errors?.['minlength']" class="form-error">
${indent}  Minimum length is ${props.minLength} characters
${indent}</div>`);
    }
    
    if (props.maxLength) {
      validationRules.push(`${indent}<div *ngIf="form.get('${controlName}')?.errors?.['maxlength']" class="form-error">
${indent}  Maximum length is ${props.maxLength} characters
${indent}</div>`);
    }
    
    if (props.pattern) {
      validationRules.push(`${indent}<div *ngIf="form.get('${controlName}')?.errors?.['pattern']" class="form-error">
${indent}  Please enter a valid format
${indent}</div>`);
    }

    if (validationRules.length === 0) return '';

    return `\n${indent}<div class="validation-errors" *ngIf="form.get('${controlName}')?.invalid && form.get('${controlName}')?.touched">
${validationRules.join('\n')}
${indent}</div>`;
  }

  /**
   * Generate form group definition
   */
  public generateFormGroup(context: GenerationContext): string {
    const { formControls } = context;
    
    if (formControls.length === 0) return '';

    const controls = formControls.map(control => {
      const validators = this.generateValidators(control);
      const defaultValue = control.defaultValue || '';
      
      return `    ${control.name}: ['${defaultValue}'${validators ? `, ${validators}` : ''}]`;
    }).join(',\n');

    return `  form = this.fb.group({
${controls}
  });`;
  }

  /**
   * Generate validators for form control
   */
  public generateValidators(control: FormControlDefinition): string {
    if (!control.validators || control.validators.length === 0) return '';
    
    const validators = control.validators.filter(v => v);
    
    if (validators.length === 1) {
      return validators[0];
    } else if (validators.length > 1) {
      return `[${validators.join(', ')}]`;
    }
    
    return '';
  }

  /**
   * Generate component imports
   */
  public generateImports(context: GenerationContext): string {
    const { imports, dependencies } = context;
    const importGroups = new Map<string, Set<string>>();
    
    // Group imports by dependency
    dependencies.forEach(dep => {
      if (!importGroups.has(dep)) {
        importGroups.set(dep, new Set());
      }
    });
    
    // Add imports to their respective dependencies
    imports.forEach(imp => {
      if (imp.includes('Form') || imp === 'Validators') {
        importGroups.get('@angular/forms')?.add(imp);
      } else {
        importGroups.get('@angular/core')?.add(imp);
      }
    });

    const importStatements: string[] = [];
    
    importGroups.forEach((imports, dependency) => {
      if (imports.size > 0) {
        const importList = Array.from(imports).sort().join(', ');
        importStatements.push(`import { ${importList} } from '${dependency}';`);
      }
    });

    return importStatements.join('\n');
  }

  /**
   * Generate constructor
   */
  public generateConstructor(context: GenerationContext): string {
    const { formControls } = context;
    
    if (formControls.length === 0) {
      return '  constructor() {}';
    }

    return `  constructor(public fb: FormBuilder) {}`;
  }

  /**
   * Generate lifecycle methods
   */
  public generateLifecycleMethods(context: GenerationContext): string {
    const { formControls } = context;
    
    if (formControls.length === 0) return '';

    return `  ngOnInit(): void {
    // Form initialization complete
    console.log('Form initialized:', this.form.value);
  }`;
  }

  /**
   * Generate component methods
   */
  public generateMethods(context: GenerationContext): string {
    const { formControls, config } = context;
    
    let methods = '';
    
    if (formControls.length > 0) {
      methods += `  onSubmit(): void {
    if (this.form.valid) {
      console.log('Form submitted:', this.form.value);
      // TODO: Implement form submission logic
    } else {
      console.log('Form is invalid');
      this.markFormGroupTouched();
    }
  }

  public markFormGroupTouched(): void {
    Object.keys(this.form.controls).forEach(key => {
      this.form.get(key)?.markAsTouched();
    });
  }`;
    }

    // Add button click handlers
    methods += `

  onButtonClick(): void {
    console.log('Button clicked');
    // TODO: Implement button click logic
  }`;

    return methods;
  }

  /**
   * Generate component imports for template
   */
  public generateComponentImports(context: GenerationContext): string {
    const { formControls } = context;
    const imports = ['CommonModule'];
    
    if (formControls.length > 0) {
      imports.push('ReactiveFormsModule');
    }
    
    return imports.join(', ');
  }

  /**
   * Extract form controls from components
   */
  public extractFormControls(components: any[]): FormControlDefinition[] {
    const controls: FormControlDefinition[] = [];
    
    const processComponent = (component: any) => {
      const formControlName = this.getFormControlName(component);
      if (formControlName) {
        const validators = this.extractValidators(component);
        const defaultValue = this.getDefaultValue(component);
        
        controls.push({
          name: formControlName,
          type: 'FormControl',
          validators,
          defaultValue
        });
      }
      
      // Process child components
      if (component.components) {
        component.components.forEach(processComponent);
      }
    };
    
    components.forEach(processComponent);
    return controls;
  }

  public extractValidators(component: any): string[] {
    const validators: string[] = [];
    const props = this.getComponentProperties(component);
    
    if (props.required) {
      validators.push('Validators.required');
    }
    
    if (props.minLength) {
      validators.push(`Validators.minLength(${props.minLength})`);
    }
    
    if (props.maxLength) {
      validators.push(`Validators.maxLength(${props.maxLength})`);
    }
    
    if (props.pattern) {
      validators.push(`Validators.pattern('${props.pattern}')`);
    }
    
    if (props.inputType === 'email') {
      validators.push('Validators.email');
    }
    
    return validators;
  }

  /**
   * Utility methods
   */
  public getComponentType(component: any): string {
    return component.type || component.get?.('type') || 'div';
  }

  public getComponentProperties(component: any): any {
    const props: any = {};
    
    // Get attributes
    if (component.attributes) {
      Object.assign(props, component.attributes);
    }
    
    // Get GrapesJS properties
    if (component.get) {
      const propertyNames = [
        'label', 'placeholder', 'required', 'disabled', 'readonly',
        'type', 'inputType', 'value', 'text', 'formControlName',
        'minLength', 'maxLength', 'pattern', 'variant', 'size',
        'buttonType', 'onClick', 'multiple', 'checked', 'layout'
      ];
      
      propertyNames.forEach(prop => {
        const value = component.get(prop);
        if (value !== undefined) {
          props[prop] = value;
        }
      });
    }
    
    return props;
  }

  public getFormControlName(component: any): string | null {
    const props = this.getComponentProperties(component);
    return props.formControlName || props.name || null;
  }

  public getDefaultValue(component: any): any {
    const props = this.getComponentProperties(component);
    return props.defaultValue || props.value || '';
  }

  public generateProperties(context: GenerationContext): string {
    // Generate any additional component properties
    return '  // Component properties';
  }

  public resolveDependencies(context: GenerationContext): ImportStatement[] {
    const dependencies: ImportStatement[] = [];
    
    dependencies.push({
      module: 'Component',
      imports: Array.from(context.imports),
      from: '@angular/core'
    });
    
    if (context.formControls.length > 0) {
      dependencies.push({
        module: 'ReactiveFormsModule',
        imports: ['ReactiveFormsModule', 'FormBuilder', 'FormGroup', 'Validators'],
        from: '@angular/forms'
      });
    }
    
    dependencies.push({
      module: 'CommonModule',
      imports: ['CommonModule'],
      from: '@angular/common'
    });
    
    return dependencies;
  }

  public createComponentMetadata(config: CodeGenerationConfig): ComponentMetadata {
    return {
      standalone: config.standalone,
      changeDetection: 'Default',
      encapsulation: 'Emulated'
    };
  }

  public generateTests(context: GenerationContext): string {
    const { className } = context;
    
    return `import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { ${className}Component } from './${context.name}.component';

describe('${className}Component', () => {
  let component: ${className}Component;
  let fixture: ComponentFixture<${className}Component>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [${className}Component, ReactiveFormsModule]
    }).compileComponents();

    fixture = TestBed.createComponent(${className}Component);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should initialize form', () => {
    expect(component.form).toBeDefined();
  });

  it('should validate required fields', () => {
    // TODO: Add specific validation tests
  });
});`;
  }

  public generateResponsiveStyles(): string {
    return `

/* Responsive Design */
@media (max-width: 768px) {
  .form-container {
    padding: var(--space-4);
  }
  
  .form-group {
    margin-bottom: var(--space-3);
  }
  
  .btn {
    width: 100%;
    justify-content: center;
  }
}

@media (max-width: 480px) {
  .form-container {
    padding: var(--space-3);
  }
  
  .form-control {
    font-size: 16px; /* Prevent zoom on iOS */
  }
}`;
  }

  /**
   * Utility methods for code formatting
   */
  public pascalCase(str: string): string {
    return str.replace(/(?:^|[\s-_])+(.)/g, (_, char) => char.toUpperCase());
  }

  public formatHTML(html: string): string {
    // Basic HTML formatting
    return html.split('\n').map(line => line.trimRight()).join('\n');
  }

  public initializeTemplates(): void {
    // Initialize template cache for performance
    this.templateCache.set('component-base', 'component template');
  }
}